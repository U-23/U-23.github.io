<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Apache服务安装使用]]></title>
    <url>%2F2019%2F05%2F05%2FApache%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.Apache的win版本下载地址。2.选择Apache 2.4.39 x64，可根据自己的需求下载对应版本。3.解压。解压出来的文件夹叫apache24。4.打开apache24/conf/httpd.conf ，修改Define SRVROOT 后面的路径为解压出来的aphace24文件夹的路径。找到Listene 80，若你的80端口被占用（可在cmd下用命令netstat -ano查看），则将80端口改为别的值，然后保存httpd.conf文件。5.用 Windows管理员身份打开cmd，切换到aphace\Apache24\bin目录下，执行httpd -k install。5.安装好了打开apache24/bin/ 双击ApacheMonitor，电脑右下角会出现图标。点击进去点击start!会变成绿色。如果没有，就解决提示的相应问题。6.去浏览器，输入localhost有页面就是成功了！出现的是aphace默认的页面！7.把自己写的html文件放进去能访问，默认的是在apache24/htdocs文件夹下面！8.局域网里面的人能访问这个文件，把localhost改成ip就好。]]></content>
      <categories>
        <category>技术</category>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[base64编码了解]]></title>
    <url>%2F2019%2F04%2F29%2Fbase64%E7%BC%96%E7%A0%81%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[关于Base64的编码转换方式。 所谓Base64，就是说选出64个字符—-小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”/“（再加上作为垫字的”=”，实际上是65个字符）—-作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。 具体来说，转换方式可以分为四步。12345678第一步，将每三个字节作为一组，一共是24个二进制位。第二步，将这24个二进制位分为四组，每个组有6个二进制位。第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节。第四步，根据下表，得到扩展后的每个字节的对应符号，这就是Base64的编码值。 12345678910111213141516171819202122232425262728293031323334 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 + 12 M 29 d 46 u 63 / 13 N 30 e 47 v 14 O 31 f 48 w 15 P 32 g 49 x 16 Q 33 h 50 y 因为，Base64将三个字节转化成四个字节，因此Base64编码后的文本，会比原文本大出三分之一左右。 举一个具体的实例，演示英语单词Man如何转成Base64编码。 Text content M a n ASCII 77 97 110 Bit pattern 0 1 0 0 1 1 0 1 0 1 1 0 0 0 0 1 0 1 1 0 1 1 1 0 Index 19 22 5 46 Base64-Encoded T W F u 1234567第一步，&quot;M&quot;、&quot;a&quot;、&quot;n&quot;的ASCII值分别是77、97、110，对应的二进制值是01001101、01100001、01101110，将它们连成一个24位的二进制字符串010011010110000101101110。第二步，将这个24位的二进制字符串分成4组，每组6个二进制位：010011、010110、000101、101110。第三步，在每组前面加两个00，扩展成32个二进制位，即四个字节：00010011、00010110、00000101、00101110。它们的十进制值分别是19、22、5、46。第四步，根据上表，得到每个值对应Base64编码，即T、W、F、u。 因此，Man的Base64编码就是TWFu。 如果字节数不足三，则这样处理：1234567a）二个字节的情况：将这二个字节的一共16个二进制位，按照上面的规则，转成三组，最后一组除了前面加两个0以外，后面也要加两个0。这样得到一个三位的Base64编码，再在末尾补上一个&quot;=&quot;号。比如，&quot;Ma&quot;这个字符串是两个字节，可以转化成三组00010011、00010110、00010000以后，对应Base64值分别为T、W、E，再补上一个&quot;=&quot;号，因此&quot;Ma&quot;的Base64编码就是TWE=。b）一个字节的情况：将这一个字节的8个二进制位，按照上面的规则转成二组，最后一组除了前面加二个0以外，后面再加4个0。这样得到一个二位的Base64编码，再在末尾补上两个&quot;=&quot;号。比如，&quot;M&quot;这个字母是一个字节，可以转化为二组00010011、00010000，对应的Base64值分别为T、Q，再补上二个&quot;=&quot;号，因此&quot;M&quot;的Base64编码就是TQ==。 再举一个中文的例子，汉字”严”如何转化成Base64编码？ 这里需要注意，汉字本身可以有多种编码，比如gb2312、utf-8、gbk等等，每一种编码的Base64对应值都不一样。下面的例子以utf-8为例。 首先，”严”的utf-8编码为E4B8A5，写成二进制就是三字节的”11100100 10111000 10100101”。将这个24位的二进制字符串，按照第3节中的规则，转换成四组一共32位的二进制值”00111001 00001011 00100010 00100101”，相应的十进制数为57、11、34、37，它们对应的Base64值就为5、L、i、l。 所以，汉字”严”（utf-8编码）的Base64值就是5Lil。 在PHP语言中，有一对专门的函数用于Base64转换：base64_encode()用于编码、base64_decode()用于解码。 这对函数的特点是，它们不管输入文本的编码是什么，都会按照规则进行Base64编码。因此，如果你想得到utf-8编码下的Base64对应值，你就必须自己保证，输入的文本是utf-8编码的。 原文链接：http://www.ruanyifeng.com/blog/2008/06/base64.html]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python运算符学习]]></title>
    <url>%2F2019%2F04%2F22%2Fpython%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Python算术运算符以下假设变量a为10，变量b为21： 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 31 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -11 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 210 / 除 - x 除以 y b / a 输出结果 2.1 % 取模 - 返回除法的余数 b % a 输出结果 1 ** 幂 - 返回x的y次幂 a**b 为10的21次方 // 取整除 - 向下取接近除数的整数 &gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5 以下实例演示了Python所有算术运算符的操作：1234567891011121314151617181920212223242526272829303132实例(Python 3.0+)#!/usr/bin/python3 a = 21b = 10c = 0 c = a + bprint (&quot;1 - c 的值为：&quot;, c) c = a - bprint (&quot;2 - c 的值为：&quot;, c) c = a * bprint (&quot;3 - c 的值为：&quot;, c) c = a / bprint (&quot;4 - c 的值为：&quot;, c) c = a % bprint (&quot;5 - c 的值为：&quot;, c) # 修改变量 a 、b 、ca = 2b = 3c = a**b print (&quot;6 - c 的值为：&quot;, c) a = 10b = 5c = a//b print (&quot;7 - c 的值为：&quot;, c) 以上实例输出结果：12345671 - c 的值为： 312 - c 的值为： 113 - c 的值为： 2104 - c 的值为： 2.15 - c 的值为： 16 - c 的值为： 87 - c 的值为： 2 Python比较运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 True。 &gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 (a &lt; b) 返回 True。 &gt;= 大于等于 - 返回x是否大于等于y。 (a &gt;= b) 返回 False。 &lt;= 小于等于 - 返回x是否小于等于y。 (a &lt;= b) 返回 True。 以下实例演示了Python所有比较运算符的操作：123456789101112131415161718192021222324252627282930313233343536373839实例(Python 3.0+)#!/usr/bin/python3 a = 21b = 10c = 0 if ( a == b ): print (&quot;1 - a 等于 b&quot;)else: print (&quot;1 - a 不等于 b&quot;) if ( a != b ): print (&quot;2 - a 不等于 b&quot;)else: print (&quot;2 - a 等于 b&quot;) if ( a &lt; b ): print (&quot;3 - a 小于 b&quot;)else: print (&quot;3 - a 大于等于 b&quot;) if ( a &gt; b ): print (&quot;4 - a 大于 b&quot;)else: print (&quot;4 - a 小于等于 b&quot;) # 修改变量 a 和 b 的值a = 5;b = 20;if ( a &lt;= b ): print (&quot;5 - a 小于等于 b&quot;)else: print (&quot;5 - a 大于 b&quot;) if ( b &gt;= a ): print (&quot;6 - b 大于等于 a&quot;)else: print (&quot;6 - b 小于 a&quot;) 以上实例输出结果：1234561 - a 不等于 b2 - a 不等于 b3 - a 大于等于 b4 - a 大于 b5 - a 小于等于 b6 - b 大于等于 a Python赋值运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a //= 取整除赋值运算符 c //= a 等效于 c = c // a 以下实例演示了Python所有赋值运算符的操作：12345678910111213141516171819202122232425262728实例(Python 3.0+)#!/usr/bin/python3 a = 21b = 10c = 0 c = a + bprint (&quot;1 - c 的值为：&quot;, c) c += aprint (&quot;2 - c 的值为：&quot;, c) c *= aprint (&quot;3 - c 的值为：&quot;, c) c /= a print (&quot;4 - c 的值为：&quot;, c) c = 2c %= aprint (&quot;5 - c 的值为：&quot;, c) c **= aprint (&quot;6 - c 的值为：&quot;, c) c //= aprint (&quot;7 - c 的值为：&quot;, c) 以上实例输出结果：12345671 - c 的值为： 312 - c 的值为： 523 - c 的值为： 10924 - c 的值为： 52.05 - c 的值为： 26 - c 的值为： 20971527 - c 的值为： 99864 Python位运算符按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下： 下表中变量 a 为 60，b 为 13二进制格式如下：12345678910111213a = 0011 1100b = 0000 1101-----------------a&amp;b = 0000 1100a|b = 0011 1101a^b = 0011 0001~a = 1100 0011 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 &#124; 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a &#124; b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 以下实例演示了Python所有位运算符的操作：123456789101112131415161718192021222324实例(Python 3.0+)#!/usr/bin/python3 a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = 0 c = a &amp; b; # 12 = 0000 1100print (&quot;1 - c 的值为：&quot;, c) c = a | b; # 61 = 0011 1101 print (&quot;2 - c 的值为：&quot;, c) c = a ^ b; # 49 = 0011 0001print (&quot;3 - c 的值为：&quot;, c) c = ~a; # -61 = 1100 0011print (&quot;4 - c 的值为：&quot;, c) c = a &lt;&lt; 2; # 240 = 1111 0000print (&quot;5 - c 的值为：&quot;, c) c = a &gt;&gt; 2; # 15 = 0000 1111print (&quot;6 - c 的值为：&quot;, c) 以上实例输出结果：1234561 - c 的值为： 122 - c 的值为： 613 - c 的值为： 494 - c 的值为： -615 - c 的值为： 2406 - c 的值为： 15 Python逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 以上实例输出结果：1234567891011121314151617181920212223242526272829303132实例(Python 3.0+)#!/usr/bin/python3 a = 10b = 20 if ( a and b ): print (&quot;1 - 变量 a 和 b 都为 true&quot;)else: print (&quot;1 - 变量 a 和 b 有一个不为 true&quot;) if ( a or b ): print (&quot;2 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;)else: print (&quot;2 - 变量 a 和 b 都不为 true&quot;) # 修改变量 a 的值a = 0if ( a and b ): print (&quot;3 - 变量 a 和 b 都为 true&quot;)else: print (&quot;3 - 变量 a 和 b 有一个不为 true&quot;) if ( a or b ): print (&quot;4 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;)else: print (&quot;4 - 变量 a 和 b 都不为 true&quot;) if not( a and b ): print (&quot;5 - 变量 a 和 b 都为 false，或其中一个变量为 false&quot;)else: print (&quot;5 - 变量 a 和 b 都为 true&quot;) 以上实例输出结果：123451 - 变量 a 和 b 都为 true2 - 变量 a 和 b 都为 true，或其中一个变量为 true3 - 变量 a 和 b 有一个不为 true4 - 变量 a 和 b 都为 true，或其中一个变量为 true5 - 变量 a 和 b 都为 false，或其中一个变量为 false Python成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 以下实例演示了Python所有成员运算符的操作：1234567891011121314151617181920212223实例(Python 3.0+)#!/usr/bin/python3 a = 10b = 20list = [1, 2, 3, 4, 5 ]; if ( a in list ): print (&quot;1 - 变量 a 在给定的列表中 list 中&quot;)else: print (&quot;1 - 变量 a 不在给定的列表中 list 中&quot;) if ( b not in list ): print (&quot;2 - 变量 b 不在给定的列表中 list 中&quot;)else: print (&quot;2 - 变量 b 在给定的列表中 list 中&quot;) # 修改变量 a 的值a = 2if ( a in list ): print (&quot;3 - 变量 a 在给定的列表中 list 中&quot;)else: print (&quot;3 - 变量 a 不在给定的列表中 list 中&quot;) 以上实例输出结果：1231 - 变量 a 不在给定的列表中 list 中2 - 变量 b 不在给定的列表中 list 中3 - 变量 a 在给定的列表中 list 中 Python身份运算符身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 注： id() 函数用于获取对象内存地址。 以下实例演示了Python所有身份运算符的操作：123456789101112131415161718192021222324252627实例(Python 3.0+)#!/usr/bin/python3 a = 20b = 20 if ( a is b ): print (&quot;1 - a 和 b 有相同的标识&quot;)else: print (&quot;1 - a 和 b 没有相同的标识&quot;) if ( id(a) == id(b) ): print (&quot;2 - a 和 b 有相同的标识&quot;)else: print (&quot;2 - a 和 b 没有相同的标识&quot;) # 修改变量 b 的值b = 30if ( a is b ): print (&quot;3 - a 和 b 有相同的标识&quot;)else: print (&quot;3 - a 和 b 没有相同的标识&quot;) if ( a is not b ): print (&quot;4 - a 和 b 没有相同的标识&quot;)else: print (&quot;4 - a 和 b 有相同的标识&quot;) 以上实例输出结果：12341 - a 和 b 有相同的标识2 - a 和 b 有相同的标识3 - a 和 b 没有相同的标识4 - a 和 b 没有相同的标识 is 与 == 区别： is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。1234567891011&gt;&gt;&gt;a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b is a True&gt;&gt;&gt; b == aTrue&gt;&gt;&gt; b = a[:]&gt;&gt;&gt; b is aFalse&gt;&gt;&gt; b == aTrue Python运算符优先级以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 and or not 逻辑运算符 以下实例演示了Python所有运算符优先级的操作：1234567891011121314151617181920实例(Python 3.0+)#!/usr/bin/python3 a = 20b = 10c = 15d = 5e = 0 e = (a + b) * c / d #( 30 * 15 ) / 5print (&quot;(a + b) * c / d 运算结果为：&quot;, e) e = ((a + b) * c) / d # (30 * 15 ) / 5print (&quot;((a + b) * c) / d 运算结果为：&quot;, e) e = (a + b) * (c / d); # (30) * (15/5)print (&quot;(a + b) * (c / d) 运算结果为：&quot;, e) e = a + (b * c) / d; # 20 + (150/5)print (&quot;a + (b * c) / d 运算结果为：&quot;, e) 以上实例输出结果：1234(a + b) * c / d 运算结果为： 90.0((a + b) * c) / d 运算结果为： 90.0(a + b) * (c / d) 运算结果为： 90.0a + (b * c) / d 运算结果为： 50.0 原文地址：http://www.runoob.com/python3/python3-basic-operators.html]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ubuntu日常使用问题总结]]></title>
    <url>%2F2019%2F04%2F19%2Fubuntu%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ubuntu日常使用中，总是出现各种奇怪的小问题。每次解决后，过段时间再次出现就忘记了，所以单独列一片文章来总结各种问题，以便日常办公。记录日常的问题。 问题1:键盘无法输出特殊字符键盘使用中shift+特殊字符，输出为其他字符。例如1shift+3 //输出为其他字符，而不是# 解决办法： fctix默认键盘配置问题，需要选择默认键盘为美式，不要选择德式什么的，那样会变成奇怪的字符。 问题2：window下编码与ubuntu下编码问题windows中文使用的是gb2312编码，当文件在ubuntu打开，运行代码后会提示utf-8编码问题。1UnicodeDecodeError: &apos;utf-8&apos; codec can&apos;t decode byte 0xd5 in position 10: invalid continuation byte 解决办法：ubuntu下使用inconv转换文件的编码方式。1234iconv -f encoding [-t encoding] [inputfile]... //-f encoding :把字符从encoding编码开始转换。 -t encoding :把字符转换到encoding编码。 例如：iconv -f gb2312 -t utf-8 student.txt &gt; student1.txt 问题3：ubuntu开机自动挂在分区双系统，一个windows，一个ubuntu。实现ubuntu开机自动挂在分区。 fstab格式：1234567file system: 分区定位，可以是磁盘号，或UUID 一般用uuid，用磁盘号维护时可能错乱。 mount point: 挂载点，如:/mnt/winc type: 挂载磁盘类型，根据实际情况填写，linux是ext4, windows是ntfs options:挂载参数，一般为defaults dump: 磁盘备份，默认为0,不备份 pass: 磁盘检查，默认不检查，0表示不检测。 实现步骤：一、查看磁盘的UUID sudo blkid 二、创建挂载点 我只挂在文档、系统两个盘符。所以在media/rj/下创建两个挂点。 sudo mkdir /home/rj/{系统,目录} 可根据自己的实际情况创建挂载点。 三、编辑/etc/fstab文件123sudo gedit /etc/fstabUUID=44E89B6754290201 /media/rj/系统 ntfs defaults 0 0UUID=0A9AD66165F33762 /media/rj/文档 ntfs defaults 0 0 四、挂载 mount -a #挂载之后，检查一下有没有编写错误的 问题4：ubuntu18.04安装引导问题(1) Ubuntu18.04 U盘启动安装，安装时出现“failed to load ldlinux.c32”选择u盘启动时，而不是uefi启动，提示此错误。找了很久，此博客可行：https://blog.csdn.net/tnaig/article/details/81139887 U盘刻录时，采用RAW的写入方式。采用这种方式，可以U盘启动进行legacy安装。(2) ubuntu18.04 uefi系统安装时出错。使用/efi分区替换/boot分区出现错误“在复制系统文件的时候出现了“无法将 grub-efi-amd64-signed 软件包安装到 /target/中。如果没有 GRUB 启动引导器，所安装的系统将无法启动。”重装多次，依旧出错。 需要使用方法：使用eif系统分区取代了boot分区]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[杂记1]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%9D%82%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[点一 困扰好多年的问题。一直无法解决。 通常学习方式都是练习-&gt;求知-&gt;练习。 可是有自我想法后，练习跟求知总是混乱了。 练习时想求知，求知时又想练习。反复周始。没有取得过结果。太乱。 点二 刚新看到一个词“囚徒困境”。有点意思。 囚徒困境（英语：Prisoner’s Dilemma）是博弈论的非零和博弈中具代表性的例子，反映个人最佳选择并非团体最佳选择。或者说在一个群体中，个人做出理性选择却往往导致集体的非理性。 个人利益趋向性和共同利益合作。 乙沉默（合作） 乙认罪（背叛） 甲沉默（合作） 二人同服刑半年 甲服刑10年；乙即时获释 甲认罪（背叛） 甲即时获释；乙服刑10年 二人同服刑5年]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MFC了解]]></title>
    <url>%2F2019%2F04%2F11%2FMFC%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[以下是我从其他网站中学的内容，后有相应的网站学习链接地址，可供学习 1.选择菜单项File-&gt;New-&gt;Project，弹出“New Project”对话框。 2.左侧面板中Installed Templated的Visual C++下选择MFC，中间窗口中选择MFC Application，然后在下面的Name编辑框中键入工程名称，本例取名“Addition”，在Location编辑框中设置工程的保存路径。点“OK”。 3.点“Next”到“Application Type”对话框，在Application type下选择Dialog based，其他使用默认设置，点“Finish”。 我们可以在Solution Explorer视图中看到，此工程的文件要比单文档应用程序少的多，在Class View中主要有三个类：CAboutDlg、CAdditionApp和CAdditionDlg。CAboutDlg是应用程序的“关于”对话框类，CAdditionApp是由CWinApp派生的类，CAdditionDlg是主对话框类，主对话框也就是此应用程序运行后显示的主要界面。 在Resource View视图中可以看到工程Addition的资源树，展开Addition.rc，下面有四个子项：Dialog（对话框）、Icon（图标）、String Table（字符串表）和Version（版本）。然后展开Dialog项，下面有两个对话框模板，其ID分别为：IDD_ABOUTBOX和IDD_ADDITION_DIALOG，前者是“关于”对话框的模板，后者是主对话框的模板。ID是资源的唯一标识，本质上是一个无符号整数，一般ID代表的整数值由系统定义，我们无需干涉。 可见对于主对话框来说，创建对话框第一步中的创建新的对话框模板已经由系统自动完成了。而如果是再添加对话框需要创建新的对话框模板时，需要在Resource View的“Dialog”节点上点右键，在右键菜单中选择“Insert Dialog”，就会生成新的对话框模板，并且会自动分配ID。 在Resource View的资源树中双击某个ID，可在中间区域内显示相应的资源界面。双击IDD_ADDITION_DIALOG时，中间区域就会显示Addition对话框模板。如下图： 在Addition对话框模板上点右键，然后在右键菜单中选择Properties，则在右侧面板中会显示对话框的属性列表。如下图： 1.ID：对话框ID，唯一标识对话框资源，可以修改。此处为IDD_ADDITION_DIALOG，我们不修改它。 2.Caption：对话框标题。此处默认为Addition，我们将其修改为“加法计算器”。 3.Border：边框类型。有四种类型：None、Thin、Resizing和Dialog Frame。我们使用默认的Dialog Frame。 4.Maximize：是否使用最大化按钮。我们使用默认的False。 5.Minimize：是否使用最小化按钮。同样我们使用默认的False。 6.Style：对话框类型。有三种类型：Overlapped（重叠窗口）、Popup（弹出式窗口）和Child（子窗口）。弹出式窗口比较常见。我们使用默认的Popup类型。 7.System Menu：是否带有标题栏左上角的系统菜单，包括移动、关闭等菜单项。我们使用默认的True。 8.Title Bar：是否带有标题栏。我们使用默认的True。 9.Font(Size)：字体类型和字体大小。如果将其修改为非系统字体，则Use System自动改为False。而如果Use System原来为False，将其修改为True，则Font(Size)自动设置为系统字体。这里我们使用默认的系统字体。 根据以上说明，其实我们只修改了标题属性。这时我们运行此程序后的界面如下： 1.为对话框添加一个静态文本框（Static Text），用于显示字符串–“被加数”。 对于自动添加的一个标题为“TODO:Place dialog controls here.”的静态文本框，这里将它删掉，继续添加新的静态文本框。 删除控件时，可以使用鼠标左键点击选中它，选中后控件的周围会出现虚线框，然后按Delete键就可以将其删除了。在“Addition”工程的Resource View中打开上一讲中创建的对话框模板IDD_ADDITION_DIALOG，自动添加的静态文本框就可以使用这种方法删除。 在添加新的静态文本框以前，先看看Toolbox视图是否显示了，如果没有显示，在菜单栏上点击View-&gt;Toolbox即可。Toolbox视图如下图： Toolbox中列出了一些常用控件，其中有一个是Static Text，即是我们要添加的控件。在Toolbox中的Static Text上点下鼠标左键不放开，并拖到IDD_ADDITION_DIALOG对话框模板上，模板上会出现一个虚线框，我们找到合适的位置松开鼠标左键放下它。 用鼠标左键选中控件后周围出现虚线框，然后鼠标移到虚线框上几个黑点的位置会变成双向箭头的形状，此时就可以按下鼠标左键并拖动来改变控件大小了。我们可以这样改变新添加的静态文本框控件的大小，以更好的显示标题。当然，整个对话框模板也可以用这种方法改变大小。 接下来就该修改静态文本框的文字了。鼠标右键点击静态文本框，在右键菜单中选择“Properties”，Properties面板就会显示出来，在面板上修改Caption属性为“被加数”，ID修改为IDC_SUMMAND_STATIC。此时模板如下图： 2.为对话框添加一个编辑框（Edit Control），用来输入被加数。 添加编辑框的过程与静态文本框类似，在Toolbox中选中Edit Control控件拖到对话框模板上，并使其与之前的静态文本框水平对齐（为了美观），然后调整其大小使之适合被加数的输入。 在编辑框上点右键，仍然在右键菜单中选择“Properties”显示出属性（Properties）面板，修改其ID为IDC_SUMMAND_EDIT。此时模板如下图： 3.按照1的方法添加一个标题为“加数”的静态文本框，用于显示字符串–“加数”。并将其ID改为IDC_ADDEND_STATIC。 4.按照2的方法添加一个ID为IDC_ADDEND_EDIT的编辑框，用来输入加数。 5.按照1的方法添加一个标题为“和”的静态文本框，用于显示文字–“和”。并修改其ID为IDC_SUM_STATIC。 6.按照2的方法添加一个ID为IDC_SUM_EDIT的编辑框，用来显示最终的加和。 7.类似的添加按钮（Button）控件到对话框模板，用于在被点击后触发加法计算。修改其标题为“计算”，ID为IDC_ADD_BUTTON。 到此，对话框模板如图： 8.删除OK按钮。打开Cancel按钮的属性面板，将标题改为“退出”，并使其与“计算”按钮水平对齐。 9.根据控件的布局，适当调整整个对话框模板的大小，使其相对控件布局来说大小合适，界面美观。 这样在对话框模板中就把我们在本例中需要用到的控件就添加完了。最终效果如下： 因为例程Addition是基于对话框的程序，所以程序自动创建了对话框模板IDD_ADDITION_DIALOG，并自动生成了对话框类CAdditionDlg，它是从CDialogEx类派生的。大家用过VC++ 6.0的可能记得，我们定义的对话框类都是从CDialog类派生的，但在VS2010中，一般对话框类都是继承自CDialogEx类。 创建对话框类 如果是自己新添加的对话框模板，怎样为它创建对话框类呢？ 1.在Resource View的“Dialog”节点上右键，然后在右键菜单中选择“Insert Dialog”创建一个新的对话框模板，ID就使用默认的IDD_DIALOG1。 2.在中间区域会显示新建的对话框模板，然后选中此对话框模板，点右键，在右键菜单中选择Add Class。 3.选择“Add Class”后会弹出一个对话框，在对话框中“Class name”下的编辑框中写入自定义的类名就可以了，例如CMyDialog。 4.最后点“Finish”完成。 最终你就可以在Class View中看到新生成的对话框类CMyDialog了，并且在Solution Explorer中有相应的MyDialog.h头文件和MyDialog.cpp源文件生成。CMyDialog类同样派生于CDialogEx类。 注意，一般类名都以C打头，又比如，CTestDlg。 为对话框中的控件添加变量 在上一讲中为对话框添加了几个控件，包括三个静态文本框，三个编辑框，一个按钮控件。程序自动生成的Cancel按钮保留，作为退出按钮，而OK按钮删除掉了。 静态文本框只是为了说明后面紧跟的编辑框中数据的意义，是被加数、加数还是和，所以它们是不会变的，我们就不为它们添加变量了。按钮控件是用来操作的，这里也不为它们添加变量。编辑框中的数据可能会经常变化，有必要为它们每个控件关联一个变量。 首先为被加数的编辑框IDC_SUMMAND_EDIT添加变量。 1.在编辑框上点右键，在右键菜单中选择“Add Variable”。弹出添加成员变量的向导对话框。 2.我们想为其添加值变量而不是控件变量，所以对话框中“Category”下的组合框中选择Value。 3.“Variable type”下的组合框此时默认选中的是“CString”，CString是字符串类，显然不能进行加法运算。我们可以选择double、float、int等。这里我们选择double，即编辑框关联一个double类型的变量。 4.在“Variable name”中写入自定义的变量名。为其取名m_editSummand。 5.点“Finish”完成。 注意，类的成员变量名一般以m_打头，以标识它是一个成员变量。 参照此方法，再分别为加数的编辑框IDD_ADDEND_EDIT添加double型变量m_editAddend、和的编辑框IDD_SUM_EDIT添加double型变量m_editSum。 对话框类的数据交换和检验 在程序运行界面中，用户往往会改变控件的属性，例如，在编辑框中输入字符串，或者改变组合框的选中项，又或者改变复选框的选中状态等。控件的属性改变后MFC会相应修改控件关联变量的值。这种同步的改变是通过MFC为对话框类自动生成的成员函数DoDataExchange()来实现的，这也叫做对话框的数据交换和检验机制。 我们为三个编辑框添加了变量以后，在AdditionDlg.cpp中CAdditionDlg的DoDataExchange()函数的函数体中多了三条DDX_Text调用语句。下面是函数体代码和添加的注释。123456789101112C++代码void CAdditionDlg::DoDataExchange(CDataExchange* pDX) &#123; // 处理MFC默认的数据交换 CDialogEx::DoDataExchange(pDX); // 处理控件IDC_SUMMAND_EDIT和变量m_editSummand之间的数据交换 DDX_Text(pDX, IDC_SUMMAND_EDIT, m_editSummand); // 处理控件IDC_ADDEND_EDIT和变量m_editAddend之间的数据交换 DDX_Text(pDX, IDC_ADDEND_EDIT, m_editAddend); // 处理控件IDC_SUM_EDIT和变量m_editSum之间的数据交换 DDX_Text(pDX, IDC_SUM_EDIT, m_editSum); &#125; 再以Addition程序为例简单说下数据交换机制。如果我们在程序运行界面中输入被加数，则通过CAddition的DoDataExchange()函数可以将输入的值保存到m_editSummand变量中，反之如果程序运行中修改了变量m_editSummand的值，则通过CAddition的DoDataExchange()函数也可以将新的变量值显示到被加数的编辑框中。 但是这种数据交换机制中，DoDataExchange()并不是被自动调用的，而是需要我们在程序中调用CDialogEx::UpdateData()函数，由UpdateData()函数再去自动调用DoDataExchange()的。 CDialogEx::UpdateData()函数的原型为： BOOL UpdateData(BOOL bSaveAndValidate = TRUE); 参数：bSaveAndValidate用于指示数据传输的方向，TRUE表示从控件传给变量，FALSE表示从变量传给控件。默认值是TRUE，即从控件传给变量。 返回值：CDialogEx::UpdateData()函数的返回值表示操作是否成功，成功则返回TRUE，否则返回FALSE。 在下一讲中将具体演示CDialogEx::UpdateData()函数如何使用。 本节主要讲的是新建对话框类和添加控件变量，控件的消息处理函数将在下一讲详细介绍。 创建对话框类和添加控件变量在上一讲中已经讲过，这一讲的主要内容是如何为控件添加消息处理函数。 MFC为对话框和控件等定义了诸多消息，我们对它们操作时会触发消息，这些消息最终由消息处理函数处理。比如我们点击按钮时就会产生BN_CLICKED消息，修改编辑框内容时会产生EN_CHANGE消息等。一般为了让某种操作达到效果，我们只需要实现某个消息的消息处理函数。 一.添加消息处理函数 以前面的加法计算器的程序为例，说明怎样为“计算”按钮控件添加消息处理函数。添加方法列出4种： 1.使用Class Wizard添加消息处理函数 用过的VC++ 6.0的朋友应该对Class Wizard很熟悉了，添加类、消息处理函数等经常会用到它，可以说是一个很核心的功能。但从VS2002开始就见不到Class Wizard了，大部分功能都集成到对话框和控件等的属性中了，使用很方便。到VS2010，久违的Class Wizard又回来了。但已经习惯了使用属性中的功能了，对于从VC++ 6.0直接转VS2010的朋友可能觉得还是使用Class Wizard比较习惯。 大家应该记得，“计算”按钮的ID为IDC_ADD_BUTTON，上图中Commands标签下，Oject IDs列表中有此ID，因为我们是想实现点击按钮后的消息处理函数，所以在Messages列表中选择BN_CLICKED消息，然后点右上方的Add Handler就可以添加BN_CLICKED消息处理函数OnClickedAddButton了。当然你也可以改名，但一般用的默认的就可以。 2.通过“Add Event Handler…”添加消息处理函数 在“计算”按钮上点右键，然后在右键菜单中选择菜单项“Add Event Handler…”，弹出“Event Handler Wizard”对话框，如下图： 可见“Message type”中默认选中的就是BN_CLICKED消息，函数名和所在类都已经自动给出，直接点“Add and Edit”就可以了。 3.在按钮的属性视图中添加消息处理函数 上面说过，从VS2002开始就主要从属性视图添加消息处理函数了。我们在“计算”按钮上点右键，在右键菜单中选择“Properties”，右侧面板中会显示按钮的属性视图。 我们可以像上图中那样，点属性视图的“Control Events”按钮（类似闪电标志），下面列出了“计算”按钮的所有消息。我们要处理的是BN_CLICKED消息，点其右侧空白列表项，会出现一个带下箭头的按钮，再点此按钮会出现“ OnBnClickedAddButton”选项，最后选中这个选项就会自动添加BN_CLICKED处理函数了。 4.双击按钮添加消息处理函数 最直接最简单的方法就是，双击“计算”按钮，MFC会自动为其在CAdditionDlg类中添加BN_CLICKED消息的处理函数OnBnClickedAddButton()。 二.在消息处理函数中添加自定义功能 在我们使用任意一种方法添加了消息处理函数以后，都只能得到一个空的OnBnClickedAddButton()函数的函数体，要实现我们想要的功能，还需要在函数体中加入自定义功能代码。 在加法计算器程序中，我们想要“计算”按钮实现的功能是，获取被加数和加数的数值，然后计算它们的和并显示到和的编辑框里。那么，OnBnClickedAddButton()的函数体就应修改为：12345678910111213C++代码void CAdditionDlg::OnBnClickedAddButton() &#123; // TODO: Add your control notification handler code here // 将各控件中的数据保存到相应的变量 UpdateData(TRUE); // 将被加数和加数的加和赋值给m_editSum m_editSum = m_editSummand + m_editAddend; // 根据各变量的值更新相应的控件。和的编辑框会显示m_editSum的值 UpdateData(FALSE); &#125; 在上面的代码中已经添加注释，大家应该很容易理解了。对于UpdateData()函数的说明在上一讲中已经介绍过，如果忘了可以再回上一讲了解了解。 接下来我们运行下此应用程序。在运行结果界面中，输入被加数5.1，加数2.3，然后点“计算”： 在上图中可以看到，点“计算”按钮后，和的编辑框中显示了正确结果：7.4。 简单分析下运行过程：输入被加数和加数，点“计算”按钮后产生点击消息，从而调用OnBnClickedAddButton()函数。进入此函数后，首先由UpdateData(TRUE)函数将被加数的值5.1和加数的值2.3分别保存到变量m_editSummand和m_editAddend，然后通过语句m_editSum = m_editSummand + m_editAddend;计算出被加数和加数的和为7.4，并把7.4赋值给m_editSum。最后调用UpdateData(FALSE)根据被加数、加数、和的值更新三个编辑框的显示值，就得到了上图中的结果。 到此，一个具有简单的加法运算功能的加法计算器应用程序就基本完成了。 本节主要讲对话框上控件的Tab顺序如何调整。 上一讲为“计算”按钮添加了消息处理函数后，加法计算器已经能够进行浮点数的加法运算。但是还有个遗留的小问题，就是对话框控件的Tab顺序问题。 运行加法计算器程序，显示对话框后不进行任何操作，直接按回车，可以看到对话框退出了。这是因为“退出”按钮是Tab顺序为1的控件，也就是第一个接受用户输入的控件。但是按照我们的输入习惯，应该是被加数的编辑框首先接受用户输入，然后是加数编辑框，再接下来是“计算”按钮，最后才是“退出”按钮。 我们先来直观的看看各个控件的Tab顺序吧。打开“Resource View”视图，然后在资源中找到对话框IDD_ADDITION_DIALOG，双击ID后中间客户区域出现其模板视图。在主菜单中选择“Format”-&gt;”Tab Order”，或者按快捷键Ctrl+D，对话框模板上就会显示各个控件的Tab顺序数字。如下图： 上图中每个控件左上角都有一个数字，这就是它的Tab响应顺序。对话框刚打开时输入焦点就在Tab顺序为1的“退出”按钮上，不做任何操作按下Tab键，输入焦点就会转移到Tab顺序为2的“被加数”静态文本框上，但是因为静态文本框不接受任何输入，所以输入焦点继续自动转移到Tab顺序为3的被加数编辑框，再按Tab键，输入焦点又会转移到Tab顺序为4的“加数”静态文本框上，同样由于它是静态文本框，输入焦点不停留继续转移到加数编辑框，后面的控件同理。 我们认为这个顺序不合理，那怎么修改呢？很简单，从自己认为Tab顺序应该为1的控件开始依次单击，随着单击的完成，各控件的Tab响应顺序也按我们的想法设置好了。 例如，此例中我们可以依次单击被加数编辑框、“被加数”静态文本框、加数编辑框、“加数”静态文本框、和编辑框、“和”静态文本框、“计算”按钮和“退出”按钮。设置完后如下图： 最后按ESC键，确认设置并退出对话框模板的Tab顺序设置状态。 现在我们再运行程序，可以看到对话框打开后最初的输入焦点在被加数编辑框上，然后我们按Tab键，输入焦点移到加数编辑框上，继续多次按Tab键时，输入焦点会按“和编辑框–‘计算’按钮–‘退出’按钮–被加数编辑框–加数编辑框–和编辑框……”的顺序循环转移。这样就达到了我们的目的。 加法计算器对话框程序大家照着做一遍后，相信对基于对话框的程序有些了解了，有个好的开始对于以后的学习大有裨益。趁热打铁，这一节讲讲什么是模态对话框和非模态对话框，以及模态对话框怎样弹出。 一.模态对话框和非模态对话框 Windows对话框分为两类：模态对话框和非模态对话框。 模态对话框是这样的对话框，当它弹出后，本应用程序其他窗口将不再接受用户输入，只有该对话框响应用户输入，在对它进行相应操作退出后，其他窗口才能继续与用户交互。 非模态对话框则是，它弹出后，本程序其他窗口仍能响应用户输入。非模态对话框一般用来显示提示信息等。 大家对Windows系统很了解，相信这两种对话框应该都遇到过。之前的加法计算器对话框其实就是模态对话框。 二.模态对话框是怎样弹出的 毕竟加法计算器程序大部分都是MFC自动生成的，对话框怎么弹出来的大家可能还不是很清楚。下面简单说说它是在哪里弹出来的，再重新建一个新的对话框并弹出它，这样大家实践以后就能更灵活的使用模态对话框了。 大家打开Addition.cpp文件，可以看到CAdditionApp类有个InitInstance()函数，在MFC应用程序框架分析中提到过此函数，不过那是单文档应用程序App类中的，函数体不太相同，但都是进行App类实例的初始化工作。 InitInstance()函数的后半部分有一段代码就是定义对话框对象并弹出对话框的，下面给出这段代码并加以注释：1234567891011121314C++代码CAdditionDlg dlg; // 定义对话框类CAdditionDlg的对象dlg m_pMainWnd = &amp;dlg; // 将dlg设为主窗口 INT_PTR nResponse = dlg.DoModal(); // 弹出对话框dlg，并将DoModal函数的返回值（退出时点击按钮的ID）赋值给nResponse if (nResponse == IDOK) // 判断返回值是否为OK按钮（其ID为IDOK，已经将它删除） &#123; // TODO: Place code here to handle when the dialog is // dismissed with OK &#125; else if (nResponse == IDCANCEL) // 判断返回值是否为Cancel按钮（其ID为IDCANCEL，将它的Caption改为了“退出”） &#123; // TODO: Place code here to handle when the dialog is // dismissed with Cancel &#125; 弹出对话框比较关键的一个函数，就是对话框类的DoModal()函数。CDialog::DoModal()函数的原型为： virtual INT_PTR DoModal(); 返回值：整数值，指定了传递给CDialog::EndDialog（该函数用于关闭对话框）的nResult参数值。如果函数不能创建对话框，则返回-1；如果出现其它错误，则返回IDABORT。 调用了它对话框就会弹出，返回值是退出对话框时所点的按钮的ID，比如，我们点了“退出”按钮，那么DoModal返回值为IDCANCEL。 三.添加一个新对话框并弹出它 再为加法计算器程序添加一个对话框，以在计算之前询问用户是否确定要进行计算。大家可以完整的看下对话框的添加和弹出过程。 1.在Resource View中的“Dialog”上点右键选择“Insert Dialog”，创建一个新的对话框模板，修改其ID为IDD_TIP_DIALOG，Caption改为“提示”，然后参考“为对话框添加控件”中所讲，在对话框模板上添加一个静态文本框（static text），Caption改为“您确定要进行加法计算吗？”，接下来修改OK按钮的Caption为“确定”，Cancel按钮的Caption为“取消”，最后调整各个控件的位置和对话框的大小。最终的对话框模板如下图： 2.根据“创建对话框类和添加控件变量”中创建对话框类的方法，在对话框模板上点右键选择“Add Class…”，弹出添加类的对话框，设置“Class name”为CTipDlg，点“OK”。在Solution Explorer中可以看到生成了CTipDlg类的头文件TipDlg.h和源文件TipDlg.cpp。 3.我们要在点“计算”按钮之后弹出此提示对话框，那么就要在“计算”按钮的消息处理函数OnBnClickedAddButton()中访问提示对话框类，所以为了访问CTipDlg类，在AdditionDlg.cpp中包含CTipDlg的头文件：#include “TipDlg.h”。 4.修改OnBnClickedAddButton()的函数体，在所有代码前，构造CTipDlg类的对象tipDlg，并通过语句tipDlg.DoModal();弹出对话框，最后判断DoModal()函数的返回值是IDOK还是IDCANCEL来确定是否继续进行计算。OnBnClickedAddButton()函数修改后如下：1234567891011121314151617181920C++代码void CAdditionDlg::OnBnClickedAddButton() &#123; // TODO: Add your control notification handler code here INT_PTR nRes; // 用于保存DoModal函数的返回值 CTipDlg tipDlg; // 构造对话框类CTipDlg的实例 nRes = tipDlg.DoModal(); // 弹出对话框 if (IDCANCEL == nRes) // 判断对话框退出后返回值是否为IDCANCEL，如果是则return，否则继续向下执行 return; // 将各控件中的数据保存到相应的变量 UpdateData(TRUE); // 将被加数和加数的加和赋值给m_editSum m_editSum = m_editSummand + m_editAddend; // 根据各变量的值更新相应的控件。和的编辑框会显示m_editSum的值 UpdateData(FALSE); &#125; 5.测试。编译运行程序后，在对话框上输入被加数和加数，点“计算”，弹出提示对话框询问是否进行计算，如果选择“确定”，则提示对话框退出，并在主对话框上显示被加数和加数的和，而如果选择“取消”，则提示对话框也会退出，但主对话框显示的和不变，即没有进行加法计算。 本节接着讲另一种对话框–非模态对话框的创建及显示。 已经说过，非模态对话框显示后，程序其他窗口仍能正常运行，可以响应用户输入，还可以相互切换。会将上一讲中创建的Tip模态对话框改为非模态对话框，让大家看下效果。 非模态对话框的对话框资源和对话框类 实际上，模态对话框和非模态对话框在创建对话框资源和生成对话框类上是没有区别的，所以上一讲中创建的IDD_TIP_DIALOG对话框资源和CTipDlg类都不需要修改。 创建及显示非模态对话框的步骤 需要修改的是，对话框类实例的创建和显示，也就是之前在CAdditionDlg::OnBnClickedAddButton()函数体中添加的对话框显示代码。下面是具体步骤： 1.在AdditionDlg.h中包含CTipDlg头文件并定义CTipDlg类型的指针成员变量。详细操作方法是，在AdditionDlg.cpp中删除之前添加的#include “TipDlg.h”，而在AdditionDlg.h中添加#include “TipDlg.h”，这是因为我们需要在AdditionDlg.h中定义CTipDlg类型的指针变量，所以要先包含它的头文件；然后在AdditionDlg.h中为CAdditionDlg类添加private成员变量CTipDlg *m_pTipDlg;。 2.在CAdditionDlg类的构造函数中初始化成员变量m_pTipDlg。如果cpp文件中函数太多，我们可以在Class View上半个视图中找到CAdditionDlg类，再在下半个视图中找到其构造函数双击，中间客户区域即可马上切到构造函数的实现处。在构造函数体中添加m_pTipDlg = NULL;，这是个好习惯，在C++编程入门系列的指针的赋值和指针运算中说到过，在任何指针变量使用前都初始化，可以避免因误访问重要内存地址而破坏此地址的数据。 3.将上一讲中添加的模态对话框显示代码注释或删除掉，添加非模态对话框的创建和显示代码。VC++中注释单行代码使用“//”，注释多行代码可以在需注释的代码开始处添加“/”，结束处添加“/”。修改后的CAdditionDlg::OnBnClickedAddButton()函数如下：123456789101112131415161718192021222324252627282930C++代码void CAdditionDlg::OnBnClickedAddButton() &#123; // TODO: Add your control notification handler code here /*INT_PTR nRes; // 用于保存DoModal函数的返回值 CTipDlg tipDlg; // 构造对话框类CTipDlg的实例 nRes = tipDlg.DoModal(); // 弹出对话框 if (IDCANCEL == nRes) // 判断对话框退出后返回值是否为IDCANCEL，如果是则return，否则继续向下执行 return;*/ // 如果指针变量m_pTipDlg的值为NULL，则对话框还未创建，需要动态创建 if (NULL == m_pTipDlg) &#123; // 创建非模态对话框实例 m_pTipDlg = new CTipDlg(); m_pTipDlg-&gt;Create(IDD_TIP_DIALOG, this); &#125; // 显示非模态对话框 m_pTipDlg-&gt;ShowWindow(SW_SHOW); // 将各控件中的数据保存到相应的变量 UpdateData(TRUE); // 将被加数和加数的加和赋值给m_editSum m_editSum = m_editSummand + m_editAddend; // 根据各变量的值更新相应的控件。和的编辑框会显示m_editSum的值 UpdateData(FALSE); &#125; 4.因为此非模态对话框实例是动态创建的，所以需要手动删除此动态对象来销毁对话框。我们在CAdditionDlg类的析构函数中添加删除代码，但是MFC并没有自动给出析构函数，这时需要我们手动添加，在对话框对象析构时就会调用我们自定义的析构函数了。在AdditionDlg.h文件中为CAdditionDlg添加析构函数声明：~CAdditionDlg();，然后在AdditionDlg.cpp文件中添加析构函数的实现，函数体如下：12345678910C++代码CAdditionDlg::~CAdditionDlg() &#123; // 如果非模态对话框已经创建则删除它 if (NULL != m_pTipDlg) &#123; // 删除非模态对话框对象 delete m_pTipDlg; &#125; &#125; 这样，非模态对话框创建和显示的代码就添加修改完了。让我们运行下看看效果吧。 在加法计算器对话框上输入被加数和加数，然后点“计算”按钮，依然像上节一样弹出了提示对话框，但是先不要关闭它，你可以拖动它后面的加法计算器对话框试试，我们发现加法计算器对话框竟然可以拖动了，而且“和”编辑框里已经显示了运算结果，这表明提示对话框显示以后还没有关闭，OnBnClickedAddButton() 就继续向下执行了，不仅如此，加法计算器的每个编辑框还都可以响应输入。 这只是一个简单的例子，非模态对话框的用处有很多，以后大家在软件开发中会用到。 本节教程就到这里了，相信大家对对话框的使用更上了一个台阶了，在不同的情况下可以选择使用模态对话框和非模态对话框了。欢迎大家留言讨论。 前面讲了模态对话框和非模态对话框，本节开始讲一种特殊的对话框–属性页对话框。另外，本套教程所讲大部分对VC++各个版本均可适用或者稍作修改即可，但考虑到终究还是基于VS2010版本的，所以将《VC++/MFC编程入门》改为《VS2010/MFC编程入门》。 属性页对话框的分类 属性页对话框想必大家并不陌生，XP系统中桌面右键点属性，弹出的就是属性页对话框，它通过标签切换各个页面。另外，我们在创建MFC工程时使用的向导对话框也属于属性页对话框，它通过点击“Next”等按钮来切换页面。 属性页对话框就是包含一般属性页对话框和向导对话框两类。它将多个对话框集成于一身，通过标签或按钮来切换页面。 属性页对话框相关类 我们使用属性页对话框时，用到的类主要有两个：CPropertyPage类和CPropertySheet类。 1.CPropertyPage类 CPropertyPage类继承自CDialog类，它被用于处理某单个的属性页，所以要为每个属性页都创建一个继承自CPropertyPage的子类。大家可以在VS2010的MSDN中查找CPropertyPage类以及它的成员的详细说明。下面就为大家讲解MSDN中列出的CPropertyPage类的部分主要成员函数。 （1）构造函数 这里讲三个CProperty类的构造函数，函数原型为：12345678910111213CPropertyPage( );explicit CPropertyPage( UINT nIDTemplate, UINT nIDCaption = 0, DWORD dwSize = sizeof(PROPSHEETPAGE));explicit CPropertyPage( LPCTSTR lpszTemplateName, UINT nIDCaption = 0, DWORD dwSize = sizeof(PROPSHEETPAGE)); 第一个是没有任何参数的构造函数。 第二个构造函数中，参数nIDTemplate是属性页的对话框资源ID，参数nIDCaption是属性页对话框选项卡的标题所用字符串资源的ID，若设为0，则选项卡标题就使用该属性页的对话框资源的标题。 第三个构造函数中，参数lpszTemplateName为属性页的对话框资源的名称字符串，不能为NULL。参数nIDCaption同上。 （2）CancelToClose()函数 在模态属性页对话框的属性页进行了某不可恢复的操作后，使用CancelToClose()函数将“OK”按钮改为“Close”按钮，并禁用“Cancel”按钮。函数原型为： void CancelToClose( ); （3）SetModified()函数 调用此函数可激活或禁用“Apply”按钮，函数原型为： void SetModified(BOOL bChanged = TRUE); （4）可重载函数 CPropertyPage类提供了一些消息处理函数，来响应属性页对话框的各种消息。我们重载这些消息处理函数，就可以自定义对属性页对话框操作的处理。可重载的消息处理函数包括： OnApply：处理属性页的“Apply”按钮被单击的消息OnCancel：处理属性页的“Cancel”按钮被单击的消息OnKillActive：处理属性页当前活动状态被切换的消息，常用于数据验证OnOK：处理属性页的“OK”按钮、“Apply”按钮或者“Close”按钮被单击的消息OnQueryCancel：处理属性页的“Cancel”按钮被单击前发出的消息OnReset：处理属性页的“Reset”按钮被单击的消息OnSetActive：处理属性页被切换为当前活动页的消息OnWizardBack：处理属性页的“Back”按钮被单击的消息，仅在向导对话框中有效OnWizardFinish：处理属性页的“Finish”按钮被单击的消息，仅在向导对话框中有效OnWizardNext：处理属性页的“Next”按钮被单击的消息，仅在向导对话框中有效 2.CPropertySheet类 CPropertySheet类继承自CWnd类，它是属性表类，负责加载、打开或删除属性页，并可以在属性页对话框中切换属性页。它跟对话框类似，也有模态和非模态两种。下面就讲解CPropertySheet类的部分成员函数。 （1）构造函数 这里依然列出CPropertySheet类的三个构造函数： CPropertySheet( ); explicit CPropertySheet( UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0); explicit CPropertySheet( LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0); 参数nIDCaption：标题的字符串资源的ID。 参数pParentWnd：属性页对话框的父窗口，若设为NULL，则父窗口为应用程序的主窗口。 参数iSelectPage：初始状态时，活动属性页的索引，默认为第一个添加到属性表的属性页。 参数pszCaption：标题字符串。 （2）GetActiveIndex()函数 获取当前活动属性页的索引。函数原型为： int GetActiveIndex( ) const; 返回值：当前活动属性页的索引。 （3）GetActivePage()函数 获取当前活动属性页对象。函数原型为： CPropertyPage* GetActivePage( ) const; 返回值：当前活动属性页对象的指针。 （4）GetPage()函数 获取某个属性页对象。函数原型为： CPropertyPage* GetPage(int nPage) const; 参数nPage：目标属性页的索引。 返回值：目标属性页对象的指针。 （5）GetPageCount()函数 获取属性页的数量。函数原型为： int GetPageCount( ) const; 返回值：属性页的数量。 （6）GetPageIndex()函数 获取某属性页在属性页对话框中的索引。函数原型为： int GetPageIndex(CPropertyPage* pPage); 参数pPage：要获取索引的属性页对象的指针。 返回值：属性页对象在属性页对话框中的索引。 （7）SetActivePage()函数 设置某个属性页为活动属性页。函数原型为： BOOL SetActivePage( int nPage); BOOL SetActivePage( CPropertyPage* pPage); 参数nPage：要设置为活动属性页的索引。 参数pPage：要设置为活动属性页的对象指针。 （8）SetWizardButtons()函数 在向导对话框上启用或禁用Back、Next或Finish按钮，应在调用DoModal之前调用此函数。函数原型为： void SetWizardButtons( DWORD dwFlags); 参数dwFlags：设置向导按钮的外观和功能属性。可以是以下值的组合： PSWIZB_BACK 启用“Back”按钮，如果不包含此值则禁用“Back”按钮。PSWIZB_NEXT 启用“Next”按钮，如果不包含此值则禁用“Next”按钮。PSWIZB_FINISH 启用“Finish”按钮。PSWIZB_DISABLEDFINISH 显示禁用的“Finish”按钮。 （9）SetWizardMode()函数 设置属性页对话框为向导对话框模式，应在调用DoModal之前调用此函数。函数原型为： void SetWizardMode( ); （10）SetTitle()函数 设置属性对话框的标题。函数原型为： void SetTitle( LPCTSTR lpszText, UINT nStyle = 0); 参数lpszText：标题字符串。 参数nStyle：指定属性表标题的风格。应当为0或PSH_PROPTITLE。如果设为PSH_PROPTITLE，则单词“Properties”会出现在指定标题之后。例如，SetTitle(“Simple”,PSH_PROPTITLE)这种调用会使得属性表标题为“Simple Properties”。 （11）AddPage()函数 为属性对话框添加新的属性页。函数原型为： void AddPage( CPropertyPage *pPage); 参数pPage：要添加的新的属性页的对象指针。 （12）PressButton()函数 模拟按下某指定的按钮。函数原型为： void PressButton( int nButton); 参数nButton：要模拟按下的按钮，它可以是下列值之一： PSBTN_BACK 选择“Back”按钮。PSBTN_NEXT 选择“Next”按钮。PSBTN_FINISH 选择“Finish”按钮。PSBTN_OK 选择“OK”按钮。PSBTN_APPLYNOW 选择“Apply”按钮。PSBTN_CANCEL 选择“Cancel”按钮。PSBTN_HELP 选择“帮助”按钮。 （13）RemovePage()函数 删除某属性页。函数原型为： void RemovePage( CPropertyPage *pPage); void RemovePage( int nPage); 参数pPage：要删除的属性页的对象指针。 参数nPage：要删除的属性页的索引。 属性对话框和相关的两个类就先介绍到这，主要是为后面使用属性页对话框做准备。有问题可以到博客交流。谢谢。 上一讲讲了属性页对话框和相关的两个类CPropertyPage类和CPropertySheet类，对使用属性页对话框做准备。本节将为大家演示如何创建向导对话框。 仍然以前面的“加法计算器”的例子为基础，在其中加入向导对话框，我们可以用它来说明加法计算器的使用方法，一步一步引导用户操作，这也是比较常见的用法。 加法计算器使用时大概可以分为三步：输入被加数、输入加数、点“计算”按钮。 就详细说明向导对话框的创建步骤： 1.创建属性页对话框资源 根据创建对话框模板和修改对话框属性中所讲方法，在“Resource View”的Dialog”节点上点右键，然后在右键菜单中选择“Insert Dialog”创建第一个对话框模板，对话框的ID属性设置为IDD_SUMMAND_PAGE，Caption属性改为“被加数页”，Style属性在下拉列表中选择“Child”，Border属性在下拉列表中选择“Thin”。 删除“OK”和“Cancel”按钮，再按照为对话框添加控件中所讲方法，添加一个静态文本框，并修改静态文本框的Caption属性为“请先输入double型被加数”。 按照上述步骤，继续添加第二个和第三个对话框资源。第二个对话框模板的ID设为IDD_ADDEND_PAGE，Caption属性改为“加数页”，也添加一个静态文本框，Caption设为“请继续输入double型加数”，其他属性同第一个对话框。第三个对话框模板的ID设为IDD_ADD_PAGE，Caption属性改为“计算页”，添加静态文本框的Caption属性改为“最后请按下“计算”按钮”，其他属性也第一个对话框一样。 2.创建属性页类 按照创建对话框类和添加控件变量中的方法，在第一个对话框模板上点右键，在右键菜单中选择“Add Class”，弹出类向导对话框，在“Class name”编辑框中输入类名“CSummandPage”，与之前不同的是，因为属性页类都应继承于CPropertyPage类，所以要修改下面“Base class”的选项，在下拉列表中选择“CPropertyPage”。 因为是第一个属性页，所以它应该有一个“下一步”按钮，在哪里添加呢？上一讲CPropertyPage类的可重载函数中提到，OnSetActive函数用于处理属性页被切换为当前活动页的消息，所以我们可以在OnSetActive函数中进行相关设置。 那怎样重载OnSetActive函数呢？我们可以在“Class View”中找到“CSummandPage”节点，点右键弹出右键菜单，选择“Properties”，然后VS2010右侧面板上会显示对话框的属性列表，属性列表的工具栏上有个tip信息为“Overrides”的按钮，按下它，下方列表中就列出了重载函数，找到“OnSetActive”，点其右侧空白列表项出现向下箭头，再点箭头就在下面出现了“OnSetActive”的选项，选择它就会自动在CSummandPage类中添加函数OnSetActive。 我们只需在OnSetActive函数体中添加相关代码就可以实现添加“下一步”按钮的效果了。新的函数体如下：123456789101112C++代码BOOL CSummandPage::OnSetActive() &#123; // TODO: Add your specialized code here and/or call the base class // 获得父窗口，即属性表CPropertySheet类 CPropertySheet* psheet = (CPropertySheet*) GetParent(); // 设置属性表只有“下一步”按钮 psheet-&gt;SetWizardButtons(PSWIZB_NEXT); return CPropertyPage::OnSetActive(); &#125; 为第二个和第三个对话框也分别添加属性页类CAddendPage和CAddPage。但第二个对话框的属性页不需要重载OnSetActive函数。第三个对话框是最后一个对话框，所以不需要“下一步”按钮，而应该换成“完成”按钮，所以也需要重载OnSetActive函数设置“完成”按钮。重载后的OnSetActive如下：123456789101112C++代码BOOL CAddPage::OnSetActive() &#123; // TODO: Add your specialized code here and/or call the base class // 获得父窗口，即属性表CPropertySheet类 CPropertySheet* psheet = (CPropertySheet*) GetParent(); //设置属性表只有“完成”按钮 psheet-&gt;SetFinishText(_T(&quot;完成&quot;)); return CPropertyPage::OnSetActive(); &#125; 上面的代码段中，字符串“完成”前加了个_T，这是因为本工程创建的时候用的默认的Unicode字符集，而如果“完成”前不加_T就是ASCII字符串。_T实际上是一个宏，工程的字符集选择为Unicode时字符串就转为Unicode字符串，选择为Muli-Byte时就转为ASCII字符串。我们可以在Solution Explorer的Addition根节点上点右键，在右键菜单上选择“Properties”，弹出工程的属性对话框，Configuration Properties-&gt;General右侧列表中的Character Set就显示选择的字符集。 那点了第三个属性页上的“完成”按钮我们想进行某些处理的话，就重载OnWizardFinish函数，方法同OnSetActive函数。重载后的OnWizardFinish函数如下：12345678910C++代码BOOL CAddPage::OnWizardFinish() &#123; // TODO: Add your specialized code here and/or call the base class // 提示向导完成 MessageBox(_T(&quot;使用说明向导已阅读完！&quot;)); return CPropertyPage::OnWizardFinish(); &#125; 3.创建属性表类 属性页资源和属性页类创建完以后，还不能生成向导对话框，我们还需要一个属性表类，来容纳这些属性页。 在Solution Explorer视图中的根节点“Addition”上点右键，在右键菜单中选择Add-&gt;Class，弹出“Add Class”对话框，然后在中间区域中选择“MFC Class”，点“Add”按钮，弹出另一个类向导对话框，设置Class name为CAddSheet，Base class选择“CPropertySheet”，点“Finish”按钮，这样就属性表类就建好了。 接下来，在新生成的AddSheet.h中包含三个属性页类的头文件： #include “SummandPage.h” #include “AddendPage.h” #include “AddPage.h” 之后在AddSheet.h中添加private变量： CSummandPage m_summandPage;CCAddendPage m_addendPage;CAddPage m_addPage; 然后在AddSheet.cpp文件中修改CAddSheet的两个构造函数为：123456789101112131415161718C++代码CAddSheet::CAddSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage) :CPropertySheet(nIDCaption, pParentWnd, iSelectPage) &#123; // 添加三个属性页到属性表 AddPage(&amp;m_summandPage); AddPage(&amp;m_addendPage); AddPage(&amp;m_addPage); &#125; CAddSheet::CAddSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage) :CPropertySheet(pszCaption, pParentWnd, iSelectPage) &#123; // 添加三个属性页到属性表 AddPage(&amp;m_summandPage); AddPage(&amp;m_addendPage); AddPage(&amp;m_addPage); &#125; 4.显示向导对话框 我们在加法计算器对话框上添加一个按钮，点击它就打开向导对话框。此按钮的ID设为IDC_INSTRUCT_BUTTON，Caption属性设为“使用说明”。 按照为控件添加消息处理函数中所讲方法，为IDC_INSTRUCT_BUTTON按钮在CAdditionDlg类中添加点击消息的处理函数OnBnClickedInstructButton。然后在AdditionDlg.cpp文件中包含CAddSheet的头文件：#include “AddSheet.h”。最后修改OnBnClickedInstructButton函数如下：123456789101112C++代码void CAdditionDlg::OnBnClickedInstructButton() &#123; // TODO: Add your control notification handler code here // 创建属性表对象 CAddSheet sheet(_T(&quot;&quot;)); // 设置属性对话框为向导对话框 sheet.SetWizardMode(); // 打开模态向导对话框 sheet.DoModal(); &#125; 到此，向导对话框就完整的创建完成了，并可以在加法计算器对话框上点“使用说明”按钮显示出来。我们来看看效果吧： 上图只是被加数页的效果，点其上“下一步”按钮就可以继续显示后面的两个页面。 是不是向导对话框没有以前想象的那般复杂了？大家可以发挥想象，进行更复杂的修改，实现更完善的功能。依然欢迎朋友们到博客来交流学习。 属性页对话框包括向导对话框和一般属性页对话框两类，上一节讲了如何创建并显示向导对话框，本节将继续介绍一般属性页对话框的创建和显示。 实际上，一般属性页对话框的创建和显示过程和向导对话框是很类似的。将上一节中的向导对话框进行少量修改，使其成为一般属性页对话框。 一般属性页对话框的创建步骤： 1.创建属性页对话框资源 属性页对话框资源的创建方法同向导对话框是一样的，上一讲中的对话框资源不需进行任何修改。 2.创建属性页类 属性页类的创建和向导对话框的属性页类也基本一样，只是一般属性页对话框中不需要“下一步”和“完成”等按钮，所以上一讲中属性页类的OnSetActive和OnWizardFinish等重载函数可以去掉。即CSummandPage类中的OnSetActive函数、CAddPage类中的OnSetActive函数和OnWizardFinish函数可以删除或注释掉。其他部分不需作任何修改。 3.创建属性表类 创建属性表类的过程同向导对话框属性表类也是一样的，所以上一讲中的CAddSheet类不需修改。 4.显示一般属性页对话框 上一讲向导对话框的显示是在OnBnClickedInstructButton函数中实现的，其中语句sheet.SetWizardMode();旨在设置属性表为向导对话框模式，所以显示一般属性页对话框时不需调用SetWizardMode成员函数。另外，我们可以将属性页对话框的标题设为“使用说明”，在构造属性表对象时将此字符串作为构造函数的参数传入。OnBnClickedInstructButton函数修改如下：1234567891011C++代码void CAdditionDlg::OnBnClickedInstructButton() &#123; // TODO: Add your control notification handler code here // 创建属性表对象 CAddSheet sheet(_T(&quot;使用说明&quot;)); // 打开模态一般属性页对话框 sheet.DoModal(); &#125; 这样一般属性页对话框的创建和显示就讲完了，我们运行下程序，在结果对话框上点“使用说明”按钮看看效果吧： 再总结下，一般属性页对话框和向导对话框的创建和显示的不同包括，是否需要OnSetActive和OnWizardFinish等重载函数，是否需要调用属性表类的SetWizardMode函数设置为向导对话框模式。 原文链接：https://blog.csdn.net/wang18323834864/article/details/78621633]]></content>
      <categories>
        <category>学习计划</category>
        <category>MFC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS学习（04/09）]]></title>
    <url>%2F2019%2F04%2F09%2F%E8%AE%A1%E5%88%92%EF%BC%882019-04-09-04-12%EF%BC%89%2F</url>
    <content type="text"><![CDATA[昨天做到每日一练的第十三题，发现网页爬取涉及到比较多的前端界面相关的知识，比如js里面的jQuery，这些都不熟悉。所以打算在进行每日一练的下一道题目之前，打算这周将js先学习了。 js学习 先看廖雪峰的JavaScript学习教程。 基本语法 JavaScript的语法和Java语言类似，每个语句以;结束，语句块用{…}。但是，JavaScript并不强制要求在每个语句的结尾加;，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上。 注意： 让JavaScript引擎自动加分号在某些情况下会改变程序的语义，导致运行结果与期望不一致。 例如，下面的一行代码就是一个完整的赋值语句： var x = 1; 下面的一行代码是一个字符串，但仍然可以视为一个完整的语句： &#39;Hello, world&#39;; 下面的一行代码包含两个语句，每个语句用;表示语句结束： var x = 1; var y = 2; // 不建议一行写多个语句! 语句块是一组语句的集合，例如，下面的代码先做了一个判断，如果判断成立，将执行{…}中的所有语句：12345if (2 &gt; 1) &#123; x = 1; y = 2; z = 3;&#125; 注意花括号{…}内的语句具有缩进，通常是4个空格。缩进不是JavaScript语法要求必须的，但缩进有助于我们理解代码的层次，所以编写代码时要遵守缩进规则。很多文本编辑器具有“自动缩进”的功能，可以帮助整理代码。{…}还可以嵌套，形成层级结构： 1234567891011if (2 &gt; 1) &#123; x = 1; y = 2; z = 3; if (x &lt; y) &#123; z = 4; &#125; if (x &gt; y) &#123; z = 5; &#125;&#125; JavaScript本身对嵌套的层级没有限制，但是过多的嵌套无疑会大大增加看懂代码的难度。遇到这种情况，需要把部分代码抽出来，作为函数来调用，这样可以减少代码的复杂度。 注释 以//开头直到行末的字符被视为单行注释， 另一种块注释是用/…/把多行字符包裹起来，把一大“块”视为一个注释： 1234/* 从这里开始是块注释仍然是注释仍然是注释注释结束 */ 数据类型Number JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型：123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等，它们和十进制表示的数值完全一样。Number可以直接做四则运算，规则和数学一致：12345671 + 2; // 3(1 + 2) * 5 / 2; // 7.52 / 0; // Infinity0 / 0; // NaN10 % 3; // 110.5 % 3; // 1.5注意%是求余运算。 字符串字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有true、false两种值，要么是true，要么是false，可以直接用true、false表示布尔值，也可以通过布尔运算计算出来：1234true; // 这是一个true值false; // 这是一个false值2 &gt; 1; // 这是一个true值2 &gt;= 3; // 这是一个false值 &amp;&amp;运算是与运算，只有所有都为true，&amp;&amp;运算结果才是true：123true &amp;&amp; true; // 这个&amp;&amp;语句计算结果为truetrue &amp;&amp; false; // 这个&amp;&amp;语句计算结果为falsefalse &amp;&amp; true &amp;&amp; false; // 这个&amp;&amp;语句计算结果为false ||运算是或运算，只要其中有一个为true，||运算结果就是true：123false || false; // 这个||语句计算结果为falsetrue || false; // 这个||语句计算结果为truefalse || true || false; // 这个||语句计算结果为true !运算是非运算，它是一个单目运算符，把true变成false，false变成true：123! true; // 结果为false! false; // 结果为true! (2 &gt; 5); // 结果为true 布尔值经常用在条件判断中，比如：123456var age = 15;if (age &gt;= 18) &#123; alert(&apos;adult&apos;);&#125; else &#123; alert(&apos;teenager&apos;);&#125; 比较运算符当我们对Number做比较时，可以通过比较运算符得到一个布尔值：1232 &gt; 5; // false5 &gt;= 2; // true7 == 7; // true 实际上，JavaScript允许对任意数据类型做比较：12false == 0; // truefalse === 0; // false 要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： NaN === NaN; // false 唯一能判断NaN的方法是通过isNaN()函数： isNaN(NaN); // true 最后要注意浮点数的相等比较： 1 / 3 === (1 - 2 / 3); // false 这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true null和undefinednull表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。 在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。 JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 数组数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。 例如： [1, 2, 3.14, &#39;Hello&#39;, null, true]; 上述数组包含6个元素。数组用[]表示，元素之间用,分隔。 另一种创建数组的方法是通过Array()函数实现： new Array(1, 2, 3); // 创建了数组[1, 2, 3] 然而，出于代码的可读性考虑，强烈建议直接使用[]。 数组的元素可以通过索引来访问。请注意，索引的起始值为0：1234var arr = [1, 2, 3.14, &apos;Hello&apos;, null, true];arr[0]; // 返回索引为0的元素，即1arr[5]; // 返回索引为5的元素，即truearr[6]; // 索引超出了范围，返回undefined 对象JavaScript的对象是一组由键-值组成的无序集合，例如：12345678var person = &#123; name: &apos;Bob&apos;, age: 20, tags: [&apos;js&apos;, &apos;web&apos;, &apos;mobile&apos;], city: &apos;Beijing&apos;, hasCar: true, zipcode: null&#125;; JavaScript对象的键都是字符串类型，值可以是任意数据类型。 上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为’Bob’，zipcode属性为null。 要获取一个对象的属性，我们用对象变量.属性名的方式：12person.name; // &apos;Bob&apos;person.zipcode; // null 变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如：12345var a; // 申明了变量a，此时a的值为undefinedvar $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 = &apos;007&apos;; // s_007是一个字符串var Answer = true; // Answer是一个布尔值truevar t = null; // t的值是null 变量名也可以用中文，但是，请不要给自己找麻烦。在JavaScript中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次， 例如：12var a = 123; // a的值是整数123a = &apos;ABC&apos;; // a变为字符串 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下：12int a = 123; // a是整数类型变量，类型用int申明a = &quot;ABC&quot;; // 错误：不能把字符串赋给整型变量 和静态语言相比，动态语言更灵活，就是这个原因。 请不要把赋值语句的等号等同于数学的等号。比如下面的代码：12var x = 10;x = x + 2; 如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。 strict模式JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量： i = 10; // i现在是全局变量在同一个页面的不同的JavaScript文件中，如果都不用var申明，恰好都使用了变量i，将造成变量i互相影响，产生难以调试的错误结果。 使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。 为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。 启用strict模式的方法是在JavaScript代码的第一行写上： &#39;use strict&#39;;这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。 来测试一下你的浏览器是否能支持strict模式： &#39;use strict&#39;;// 如果浏览器支持strict模式，// 下面的代码将报ReferenceError错误:abc = &#39;Hello, world&#39;;运行代码，如果浏览器报错，请修复后再运行。如果浏览器不报错，说明你的浏览器太古老了，需要尽快升级。 不用var申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。我们在后面编写的JavaScript代码将全部采用strict模式。 字符串JavaScript的字符串就是用’’或””括起来的字符表示。 如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。 如果字符串内部既包含’又包含”怎么办？可以用转义字符\来标识，比如： &#39;I\&#39;m \&quot;OK\&quot;!&#39;; 表示的字符串内容是：I’m “OK”! 转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\表示的字符就是\。 ASCII字符可以以\x##形式的十六进制表示，例如：1234&apos;\x41&apos;; // 完全等同于 &apos;A&apos;还可以用\u####表示一个Unicode字符：&apos;\u4e2d\u6587&apos;; // 完全等同于 &apos;中文&apos; 多行字符串由于多行字符串用\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ... 表示： 这是一个 多行 字符串;注意：反引号在键盘的ESC下方，数字键1的左边： 模板字符串要把多个字符串连接起来，可以用+号连接：1234var name = &apos;小明&apos;;var age = 20;var message = &apos;你好, &apos; + name + &apos;, 你今年&apos; + age + &apos;岁了!&apos;;alert(message); 如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：1234var name = &apos;小明&apos;;var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;alert(message); 123456&apos;use strict&apos;;// 如果浏览器支持模板字符串，将会替换字符串内部的变量:var name = &apos;小明&apos;;var age = 20;console.log(`你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`); 1234567891011var s = &apos;Hello, world!&apos;;s.length; // 13要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：var s = &apos;Hello, world!&apos;;s[0]; // &apos;H&apos;s[6]; // &apos; &apos;s[7]; // &apos;w&apos;s[12]; // &apos;!&apos;s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined 需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：123var s = &apos;Test&apos;;s[0] = &apos;X&apos;;alert(s); // s仍然为&apos;Test&apos; JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：1234567891011toUpperCasetoUpperCase()把一个字符串全部变为大写：var s = &apos;Hello&apos;;s.toUpperCase(); // 返回&apos;HELLO&apos;toLowerCasetoLowerCase()把一个字符串全部变为小写：var s = &apos;Hello&apos;;var lower = s.toLowerCase(); // 返回&apos;hello&apos;并赋值给变量lowerlower; // &apos;hello&apos; indexOfindexOf()会搜索指定字符串出现的位置：123var s = &apos;hello, world&apos;;s.indexOf(&apos;world&apos;); // 返回7s.indexOf(&apos;World&apos;); // 没有找到指定的子串，返回-1 substringsubstring()返回指定索引区间的子串：123var s = &apos;hello, world&apos;s.substring(0, 5); // 从索引0开始到5（不包括5），返回&apos;hello&apos;s.substring(7); // 从索引7开始到结束，返回&apos;world&apos; 数组JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。 要取得Array的长度，直接访问length属性：12var arr = [1, 2, 3.14, &apos;Hello&apos;, null, true];arr.length; // 6 请注意，直接给Array的length赋一个新的值会导致Array大小的变化：123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array：123var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];arr[1] = 99;arr; // arr现在变为[&apos;A&apos;, 99, &apos;C&apos;] 请注意，如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化：123var arr = [1, 2, 3];arr[5] = &apos;x&apos;;arr; // arr变为[1, 2, 3, undefined, undefined, &apos;x&apos;] 大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。 indexOf与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置：12345var arr = [10, 20, &apos;30&apos;, &apos;xyz&apos;];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf(&apos;30&apos;); // 元素&apos;30&apos;的索引为2 注意了，数字30和字符串’30’是不同的元素。 sliceslice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array：123var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];arr.slice(0, 3); // **从索引0开始，到索引3结束，但不包括索引3**: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]arr.slice(3); // 从索引3开始到结束: [&apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;] 注意到slice()的起止参数包括开始索引，不包括结束索引。 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array：1234var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];var aCopy = arr.slice();aCopy; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]aCopy === arr; // false push和poppush()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉：123456789var arr = [1, 2];arr.push(&apos;A&apos;, &apos;B&apos;); // 返回Array新的长度: 4arr; // [1, 2, &apos;A&apos;, &apos;B&apos;]arr.pop(); // pop()返回&apos;B&apos;arr; // [1, 2, &apos;A&apos;]arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] unshift和shift如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：123456789var arr = [1, 2];arr.unshift(&apos;A&apos;, &apos;B&apos;); // 返回Array新的长度: 4arr; // [&apos;A&apos;, &apos;B&apos;, 1, 2]arr.shift(); // &apos;A&apos;arr; // [&apos;B&apos;, 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // [] sortsort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序：123var arr = [&apos;B&apos;, &apos;C&apos;, &apos;A&apos;];arr.sort();arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] 能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。 reversereverse()把整个Array的元素给掉个个，也就是反转：123var arr = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;];arr.reverse(); arr; // [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;] splicesplice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：12345678910var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]// 只删除,不添加:arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]// 只添加,不删除:arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;] concatconcat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array：1234var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];var added = arr.concat([1, 2, 3]);added; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3]arr; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] 请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array. 实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里：12var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];arr.concat(1, 2, [3, 4]); // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3, 4] joinjoin()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：12var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3];arr.join(&apos;-&apos;); // &apos;A-B-C-1-2-3&apos; 如果Array的元素不是字符串，将自动转换为字符串后再连接。 多维数组如果数组的某个元素又是一个Array，则可以形成多维数组，例如： var arr = [[1, 2, 3], [400, 500, 600], &#39;-&#39;];上述Array包含3个元素，其中头两个元素本身也是Array。 小结Array提供了一种顺序存储一组元素的功能，并可以按索引来读写。 对象JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。 JavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他：12345678var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, school: &apos;No.1 Middle School&apos;, height: 1.70, weight: 65, score: null&#125;; JavaScript用一个{…}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。 上述对象申明了一个name属性，值是’小明’，birth属性，值是1990，以及其他一些属性。最后，把这个对象赋值给变量xiaoming后，就可以通过变量xiaoming来获取小明的属性了：12xiaoming.name; // &apos;小明&apos;xiaoming.birth; // 1990 访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用’’括起来：1234var xiaohong = &#123; name: &apos;小红&apos;, &apos;middle-school&apos;: &apos;No.1 Middle School&apos;&#125;; xiaohong的属性名middle-school不是一个有效的变量，就需要用’’括起来。访问这个属性也无法使用.操作符，必须用[‘xxx’]来访问：123xiaohong[&apos;middle-school&apos;]; // &apos;No.1 Middle School&apos;xiaohong[&apos;name&apos;]; // &apos;小红&apos;xiaohong.name; // &apos;小红&apos; 也可以用xiaohong[‘name’]来访问xiaohong的name属性，不过xiaohong.name的写法更简洁。我们在编写JavaScript代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过object.prop的形式访问一个属性了。 实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。 如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回undefined：1234567&apos;use strict&apos;;var xiaoming = &#123; name: &apos;小明&apos;&#125;;console.log(xiaoming.name);console.log(xiaoming.age); // undefined 由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：1234567891011var xiaoming = &#123; name: &apos;小明&apos;&#125;;xiaoming.age; // undefinedxiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming[&apos;name&apos;]; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 如果我们要检测xiaoming是否拥有某一属性，可以用in操作符：12345678910var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, school: &apos;No.1 Middle School&apos;, height: 1.70, weight: 65, score: null&#125;;&apos;name&apos; in xiaoming; // true&apos;grade&apos; in xiaoming; // false 不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的： &#39;toString&#39; in xiaoming; // true因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。 要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：12345var xiaoming = &#123; name: &apos;小明&apos;&#125;;xiaoming.hasOwnProperty(&apos;name&apos;); // truexiaoming.hasOwnProperty(&apos;toString&apos;); // false 判断JavaScript使用if () { … } else { … }来进行条件判断。例如，根据年龄显示不同内容，可以用if语句实现如下：123456var age = 20;if (age &gt;= 18) &#123; // 如果age &gt;= 18为true，则执行if语句块 alert(&apos;adult&apos;);&#125; else &#123; // 否则执行else语句块 alert(&apos;teenager&apos;);&#125; 其中else语句是可选的。如果语句块只包含一条语句，那么可以省略{}：12345var age = 20;if (age &gt;= 18) alert(&apos;adult&apos;);else alert(&apos;teenager&apos;); 省略{}的危险之处在于，如果后来想添加一些语句，却忘了写{}，就改变了if…else…的语义，例如：123456var age = 20;if (age &gt;= 18) alert(&apos;adult&apos;);else console.log(&apos;age &lt; 18&apos;); // 添加一行日志 alert(&apos;teenager&apos;); // &lt;- 这行语句已经不在else的控制范围了 上述代码的else子句实际上只负责执行console.log(‘age &lt; 18’);，原有的alert(‘teenager’);已经不属于if…else…的控制范围了，它每次都会执行。 相反地，有{}的语句就不会出错：1234567var age = 20;if (age &gt;= 18) &#123; alert(&apos;adult&apos;);&#125; else &#123; console.log(&apos;age &lt; 18&apos;); alert(&apos;teenager&apos;);&#125; 这就是为什么我们建议永远都要写上{}。 多行条件判断如果还要更细致地判断条件，可以使用多个if…else…的组合：12345678var age = 3;if (age &gt;= 18) &#123; alert(&apos;adult&apos;);&#125; else if (age &gt;= 6) &#123; alert(&apos;teenager&apos;);&#125; else &#123; alert(&apos;kid&apos;);&#125; 上述多个if…else…的组合实际上相当于两层if…else…：12345678910var age = 3;if (age &gt;= 18) &#123; alert(&apos;adult&apos;);&#125; else &#123; if (age &gt;= 6) &#123; alert(&apos;teenager&apos;); &#125; else &#123; alert(&apos;kid&apos;); &#125;&#125; 但是我们通常把else if连写在一起，来增加可读性。这里的else略掉了{}是没有问题的，因为它只包含一个if语句。注意最后一个单独的else不要略掉{}。 请注意，if…else…语句的执行特点是二选一，在多个if…else…语句中，如果某个条件成立，则后续就不再继续判断了。 循环循环要计算1+2+3，我们可以直接写表达式： 1 + 2 + 3; // 6要计算1+2+3+…+10，勉强也能写出来。 但是，要计算1+2+3+…+10000，直接写表达式就不可能了。 为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。 JavaScript的循环有两种，一种是for循环，通过初始条件、结束条件和递增条件来循环执行语句块：123456var x = 0;var i;for (i=1; i&lt;=10000; i++) &#123; x = x + i;&#125;x; // 50005000 让我们来分析一下for循环的控制条件： i=1 这是初始条件，将变量i置为1；i&lt;=10000 这是判断条件，满足时就继续循环，不满足就退出循环；i++ 这是每次循环后的递增条件，由于每次循环后变量i都会加1，因此它终将在若干次循环后不满足判断条件i&lt;=10000而退出循环。 for循环最常用的地方是利用索引来遍历数组：123456var arr = [&apos;Apple&apos;, &apos;Google&apos;, &apos;Microsoft&apos;];var i, x;for (i=0; i&lt;arr.length; i++) &#123; x = arr[i]; console.log(x);&#125; for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环：1234567var x = 0;for (;;) &#123; // 将无限循环下去 if (x &gt; 100) &#123; break; // 通过if判断来退出循环 &#125; x ++;&#125; for … infor循环的一个变体是for … in循环，它可以把一个对象的所有属性依次循环出来：12345678var o = &#123; name: &apos;Jack&apos;, age: 20, city: &apos;Beijing&apos;&#125;;for (var key in o) &#123; console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;&#125; 要过滤掉对象继承的属性，用hasOwnProperty()来实现：12345678910var o = &#123; name: &apos;Jack&apos;, age: 20, city: &apos;Beijing&apos;&#125;;for (var key in o) &#123; if (o.hasOwnProperty(key)) &#123; console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos; &#125;&#125; 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for … in循环可以直接循环出Array的索引：12345var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];for (var i in a) &#123; console.log(i); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos; console.log(a[i]); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;&#125; 请注意，for … in对Array的循环得到的是String而不是Number。 whilefor循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的for循环容易让人看不清循环的逻辑，此时用while循环更佳。 while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：1234567var x = 0;var n = 99;while (n &gt; 0) &#123; x = x + n; n = n - 2;&#125;x; // 2500 在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。 do … while最后一种循环是do { … } while()循环，它和while循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件：12345var n = 0;do &#123; n = n + 1;&#125; while (n &lt; 100);n; // 100 用do { … } while()循环要小心，循环体会至少执行1次，而for和while循环则可能一次都不执行。 Map和SetJavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。 但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。 为了解决这个问题，最新的ES6规范引入了新的数据类型Map。要测试你的浏览器是否支持ES6规范，请执行以下代码，如果浏览器报ReferenceError错误，那么你需要换一个支持ES6的浏览器： Map是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：12var names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;];var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。 如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：12var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);m.get(&apos;Michael&apos;); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：1234567var m = new Map(); // 空Mapm.set(&apos;Adam&apos;, 67); // 添加新的key-valuem.set(&apos;Bob&apos;, 59);m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: truem.get(&apos;Adam&apos;); // 67m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;m.get(&apos;Adam&apos;); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：1234var m = new Map();m.set(&apos;Adam&apos;, 67);m.set(&apos;Adam&apos;, 88);m.get(&apos;Adam&apos;); // 88 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤：12var s = new Set([1, 2, 3, 3, &apos;3&apos;]);s; // Set &#123;1, 2, 3, &quot;3&quot;&#125; 注意数字3和字符串’3’是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：1234s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.add(4);s; // 仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素：1234var s = new Set([1, 2, 3]);s; // Set &#123;1, 2, 3&#125;s.delete(3);s; // Set &#123;1, 2&#125; Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。 iterable遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for … of循环来遍历。 用for … of循环遍历集合，用法如下：123456789101112var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + &apos;=&apos; + x[1]);&#125; 你可能会有疑问，for … of循环和for … in循环有何区别？ for … in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。 当我们手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果：12345var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];a.name = &apos;Hello&apos;;for (var x in a) &#123; console.log(x); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;name&apos;&#125; for … in循环将把name包括在内，但Array的length属性却不包括在内。for … of循环则完全修复了这些问题，它只循环集合本身的元素：12345var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];a.name = &apos;Hello&apos;;for (var x of a) &#123; console.log(x); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;&#125; 这就是为什么要引入新的for … of循环。 然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：12345678&apos;use strict&apos;;var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + &apos;, index = &apos; + index);&#125;); 注意，forEach()方法是ES5.1标准引入的，你需要测试浏览器是否支持。 Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：1234var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;); Map的回调函数参数依次为value、key和map本身：1234var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);m.forEach(function (value, key, map) &#123; console.log(value);&#125;); 如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element：1234var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];a.forEach(function (element) &#123; console.log(element);&#125;); 函数我们知道圆的面积计算公式为： S = πr2 当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：123456var r1 = 12.34;var r2 = 9.08;var r3 = 73.1;var s1 = 3.14 * r1 * r1;var s2 = 3.14 * r2 * r2;var s3 = 3.14 * r3 * r3; 当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 x x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。 有了函数，我们就不再每次写s = 3.14 x x，而是写成更有意义的函数调用s = area_of_circle(x)，而函数area_of_circle本身只需要写一次，就可以多次调用。 基本上所有的高级语言都支持函数，JavaScript也不例外。JavaScript的函数不但是“头等公民”，而且可以像变量一样使用，具有非常强大的抽象能力。 抽象抽象是数学中非常常见的概念。举个例子： 计算数列的和，比如：1 + 2 + 3 + … + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作：123100∑nn=1 这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。 而且，这种抽象记法是可扩展的，比如：123100∑(n^2+1)n=1 还原成加法运算就变成了： (1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1) 可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。 函数定义和调用定义函数在JavaScript中，定义函数的方式如下：1234567function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125; 上述abs()函数的定义如下： function指出这是一个函数定义；abs是函数的名称；(x)括号内列出函数的参数，多个参数以,分隔；{ … }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。 如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined。 由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。 因此，第二种定义函数的方式如下：1234567var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;; 在这种方式下，function (x) { … }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。 上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。 调用函数调用函数时，按顺序传入参数即可：12abs(10); // 返回10abs(-9); // 返回9 由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数： abs(10, ‘blablabla’); // 返回10abs(-9, ‘haha’, ‘hehe’, null); // 返回9传入的参数比定义的少也没有问题： abs(); // 返回NaN此时abs(x)函数的参数x将收到undefined，计算结果为NaN。 要避免收到undefined，可以对参数进行检查：12345678910function abs(x) &#123; if (typeof x !== &apos;number&apos;) &#123; throw &apos;Not a number&apos;; &#125; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125; argumentsJavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：1234567&apos;use strict&apos;function foo(x) &#123; console.log(&apos;x = &apos; + x); // 10 for (var i=0; i&lt;arguments.length; i++) &#123; console.log(&apos;arg &apos; + i + &apos; = &apos; + arguments[i]); // 10, 20, 30 &#125;&#125; 利用arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：1234567891011function abs() &#123; if (arguments.length === 0) &#123; return 0; &#125; var x = arguments[0]; return x &gt;= 0 ? x : -x;&#125;abs(); // 0abs(10); // 10abs(-9); // 9 实际上arguments最常用于判断传入参数的个数。你可能会看到这样的写法： // foo(a[, b], c)// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：12345678function foo(a, b, c) &#123; if (arguments.length === 2) &#123; // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 &#125; // ...&#125; 要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。 rest参数由于JavaScript函数允许接收任意个参数，于是我们就不得不用arguments来获取所有参数：1234567891011function foo(a, b) &#123; var i, rest = []; if (arguments.length &gt; 2) &#123; for (i = 2; i&lt;arguments.length; i++) &#123; rest.push(arguments[i]); &#125; &#125; console.log(&apos;a = &apos; + a); console.log(&apos;b = &apos; + b); console.log(rest);&#125; 为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？ ES6标准引入了rest参数，上面的函数可以改写为：1234567891011121314151617function foo(a, b, ...rest) &#123; console.log(&apos;a = &apos; + a); console.log(&apos;b = &apos; + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] rest参数只能写在最后，前面用…标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。 变量作用域与解构赋值在JavaScript中，用var申明的变量实际上是有作用域的。 如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：12345678&apos;use strict&apos;;function foo() &#123; var x = 1; x = x + 1;&#125;x = x + 2; // ReferenceError! 无法在函数体外引用变量x 如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：1234567891011&apos;use strict&apos;;function foo() &#123; var x = 1; x = x + 1;&#125;function bar() &#123; var x = &apos;A&apos;; x = x + &apos;B&apos;;&#125; 由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：123456789&apos;use strict&apos;;function foo() &#123; var x = 1; function bar() &#123; var y = x + 1; // bar可以访问foo的变量x! &#125; var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!&#125; 如果内部函数和外部函数的变量名重名怎么办？来测试一下：123456789101112131415&apos;use strict&apos;;function foo() &#123; var x = 1; function bar() &#123; var x = &apos;A&apos;; console.log(&apos;x in bar() = &apos; + x); // &apos;A&apos; &#125; console.log(&apos;x in foo() = &apos; + x); // 1 bar();&#125;foo(); x in foo() = 1 x in bar() = A 这说明JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。 变量提升JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：123456789&apos;use strict&apos;;function foo() &#123; var x = &apos;Hello, &apos; + y; console.log(x); var y = &apos;Bob&apos;;&#125;foo(); 虽然是strict模式，但语句var x = ‘Hello, ‘ + y;并不报错，原因是变量y在稍后申明了。但是console.log显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。 对于上述foo()函数，JavaScript引擎看到的代码相当于：123456function foo() &#123; var y; // 提升变量y的申明，此时y为undefined var x = &apos;Hello, &apos; + y; console.log(x); y = &apos;Bob&apos;;&#125; 由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量：12345678910function foo() &#123; var x = 1, // x初始化为1 y = x + 1, // y初始化为2 z, i; // z和i为undefined // 其他语句: for (i=0; i&lt;100; i++) &#123; ... &#125;&#125; 全局作用域不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：12345&apos;use strict&apos;;var course = &apos;Learn JavaScript&apos;;alert(course); // &apos;Learn JavaScript&apos;alert(window.course); // &apos;Learn JavaScript&apos; 因此，直接访问全局变量course和访问window.course是完全一样的。 你可能猜到了，由于函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象：12345678&apos;use strict&apos;;function foo() &#123; alert(&apos;foo&apos;);&#125;foo(); // 直接调用foo()window.foo(); // 通过window.foo()调用 进一步大胆地猜测，我们每次直接调用的alert()函数其实也是window的一个变量：123456789101112&apos;use strict&apos;;window.alert(&apos;调用window.alert()&apos;);// 把alert保存到另一个变量:var old_alert = window.alert;// 给alert赋一个新函数:window.alert = function () &#123;&#125;alert(&apos;无法用alert()显示了!&apos;);// 恢复alert:window.alert = old_alert;alert(&apos;又可以用alert()了!&apos;); 这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。 名字空间 全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = &apos;myapp&apos;;MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return &apos;foo&apos;;&#125;; 把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。 许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。 局部作用域 由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：12345678&apos;use strict&apos;;function foo() &#123; for (var i=0; i&lt;100; i++) &#123; // &#125; i += 100; // 仍然可以引用变量i&#125; 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：12345678910&apos;use strict&apos;;function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; // SyntaxError: i += 1;&#125; 常量由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”： var PI = 3.14;ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域： ‘use strict’; const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14解构赋值从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。 什么是解构赋值？我们先看看传统的做法，如何把一个数组的元素分别赋值给几个变量： var array = [‘hello’, ‘JavaScript’, ‘ES6’];var x = array[0];var y = array[1];var z = array[2];现在，在ES6中，可以使用解构赋值，直接对多个变量同时赋值： ‘use strict’; // 如果浏览器支持解构赋值就不会报错:var [x, y, z] = [‘hello’, ‘JavaScript’, ‘ES6’];// x, y, z分别被赋值为数组对应元素:console.log(‘x = ‘ + x + ‘, y = ‘ + y + ‘, z = ‘ + z); 注意，对数组元素进行解构赋值时，多个变量要用[…]括起来。 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致： let [x, [y, z]] = [‘hello’, [‘JavaScript’, ‘ES6’]];x; // ‘hello’y; // ‘JavaScript’z; // ‘ES6’解构赋值还可以忽略某些元素： let [, , z] = [‘hello’, ‘JavaScript’, ‘ES6’]; // 忽略前两个元素，只对z赋值第三个元素z; // ‘ES6’如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性： ‘use strict’; var person = { name: ‘小明’, age: 20, gender: ‘male’, passport: ‘G-12345678’, school: ‘No.4 middle school’};var {name, age, passport} = person;// name, age, passport分别被赋值为对应属性:console.log(‘name = ‘ + name + ‘, age = ‘ + age + ‘, passport = ‘ + passport); 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的： var person = { name: ‘小明’, age: 20, gender: ‘male’, passport: ‘G-12345678’, school: ‘No.4 middle school’, address: { city: ‘Beijing’, street: ‘No.1 Road’, zipcode: ‘100001’ }};var {name, address: {city, zip}} = person;name; // ‘小明’city; // ‘Beijing’zip; // undefined, 因为属性名是zipcode而不是zip// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:address; // Uncaught ReferenceError: address is not defined使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取： var person = { name: ‘小明’, age: 20, gender: ‘male’, passport: ‘G-12345678’, school: ‘No.4 middle school’}; // 把passport属性赋值给变量id:let {name, passport:id} = person;name; // ‘小明’id; // ‘G-12345678’// 注意: passport不是变量，而是为了让变量id获得passport属性:passport; // Uncaught ReferenceError: passport is not defined解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题： var person = { name: ‘小明’, age: 20, gender: ‘male’, passport: ‘G-12345678’}; // 如果person对象没有single属性，默认赋值为true:var {name, single=true} = person;name; // ‘小明’single; // true有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误： // 声明变量:var x, y;// 解构赋值:{x, y} = { name: ‘小明’, x: 100, y: 200};// 语法错误: Uncaught SyntaxError: Unexpected token =这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来： ({x, y} = { name: ‘小明’, x: 100, y: 200});使用场景解构赋值在很多时候可以大大简化代码。例如，交换两个变量x和y的值，可以这么写，不再需要临时变量： var x=1, y=2;[x, y] = [y, x]快速获取当前页面的域名和路径： var {hostname:domain, pathname:path} = location;如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个Date对象： function buildDate({year, month, day, hour=0, minute=0, second=0}) { return new Date(year + ‘-‘ + month + ‘-‘ + day + ‘ ‘ + hour + ‘:’ + minute + ‘:’ + second);}它的方便之处在于传入的对象只需要year、month和day这三个属性： buildDate({ year: 2017, month: 1, day: 1 });// Sun Jan 01 2017 00:00:00 GMT+0800 (CST)也可以传入hour、minute和second属性： buildDate({ year: 2017, month: 1, day: 1, hour: 20, minute: 15 });// Sun Jan 01 2017 20:15:00 GMT+0800 (CST)使用解构赋值可以减少代码量，但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行。目前支持解构赋值的浏览器包括Chrome，Firefox，Edge等。 原文链接：https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000]]></content>
      <categories>
        <category>学习计划</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[敏感词替换]]></title>
    <url>%2F2019%2F04%2F08%2F%E4%BB%A3%E6%9B%BF%E6%95%8F%E6%84%9F%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[用特殊字符代替敏感词汇。步骤如下 一、先定义敏感词汇 二、输入的词汇跟定义的敏感词进行匹配 三、替换敏感词汇 四、输出 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/envpython3#-*-coding:utf-8-*-class Input(object): def __init__(self): self.filtered_words = list() self.in_string = &apos;&apos; self.out_string = &apos;Human Rights&apos; self.load_filtered_words() def load_filtered_words(self, filename=&apos;filtered_words.txt&apos;): with open(filename) as file: for line in file.readlines(): self.filtered_words.append(line.strip()) def filter_words(self): self.out_string = self.in_string for word in self.filtered_words: if word in self.out_string: self.out_string = self.out_string.replace(word, len(word)*&apos;*&apos;) def user_input(self, filename=&apos;exercise.txt&apos;): try: f = open(&apos;exercise.txt&apos;) f.close except: self.in_string = input(&apos;&gt;&apos;) else: with open(filename) as file: self.in_string = file.read() def std_output(self): self.filter_words() print(self.out_string)if __name__ == &apos;__main__&apos;: i = Input() i.user_input() i.std_output() 结果显示 作者：匿名用户题目：第十二题链接：https://github.com/Yixiaohan/show-me-the-code]]></content>
      <categories>
        <category>每天一练</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 16.04无法安装无线网卡驱动]]></title>
    <url>%2F2019%2F03%2F26%2Fubuntu%2016.04%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[昨天把笔记本格盘装了Ubuntu16.04同样是WiFi打不开（点击开启却又自动关闭）（蓝牙也是同样打不开），和题主一样的情况，在附加驱动里面是没有无线网卡驱动。查了一下网卡是 Intel® Dual Band Wireless-AC 3165 ，查了不少CSDN博客，3165 的网卡驱动在 Kernel 4.1+ 才被添加，但我 Kernel 都 4.13 了喂（摔）。 12uname -a$ Linux Twilight 4.13.0-32-generic #35~16.04.1-Ubuntu SMP Thu Jan 25 10:13:43 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux lib/firmware/ 下也有相应的固件。（但就是打不开我也很绝望啊） 可以根据自己的网卡来这儿找固件（如果没有的话）：https://link.zhihu.com/?target=https%3A//wireless.wiki.kernel.org/en/users/Drivers/iwlwifi然后顺手 rfkill 看了下：12345678910111213rfkill list all$ 0: ideapad_wlan: Wireless LAN Soft blocked: no Hard blocked: yes 1: ideapad_bluetooth: Bluetooth Soft blocked: yes Hard blocked: yes 2: hci0: Bluetooth Soft blocked: yes Hard blocked: no 3: phy0: Wireless LAN Soft blocked: no Hard blocked: no 绝了，这硬件给锁了。 那就直接把这个模块移除了。 123sudo modprode -r &lt; WIRELESS DRIVER &gt;# 答主的是直接这样了：# sudo modprobe -r ideapad_laptop Rua！然后就可以打开无线网络了(蓝牙也可以使用了)。 看了下好像有两个网卡（？）还有个大螃蟹的。123lspci$ 03:00.0 Network controller: Intel Corporation Intel Dual Band Wireless-AC 3165 Plus Bluetooth (rev 99) 04:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 10) 没有找到官方相关Linux下的驱动 emmm 找到了一个开源驱动：rtlwifi_new 123git clone https://github.com/lwfinger/rtlwifi_new.gitcd rtlwifi_newsudo make &amp;&amp; make install 重启就好了。但是每次重启都要重新移除模块比较麻烦，把下面的添加到 /etc/rc.local1echo 'password' | sudo sudo modprode -r &lt; WIRELESS DRIVER &gt; 以上 作者：匿名用户链接：https://www.zhihu.com/question/264008505/answer/314220196来源：知乎著作权归作者所有.]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
</search>
